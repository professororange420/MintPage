import{C as F,_ as C,dt as A,du as D,bW as L,bX as R,B as o,b0 as G,dv as k,bL as T,dw as _,aR as p,dx as b,dy as z,dz as B}from"./index-42fc860b.js";import{H as N}from"./http-rpc-client-0a079e80.browser.esm-4f15a983.js";const u=5e4,g=113,W={Transaction:[{name:"txType",type:"uint256"},{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"gasLimit",type:"uint256"},{name:"gasPerPubdataByteLimit",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymaster",type:"uint256"},{name:"nonce",type:"uint256"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"factoryDeps",type:"bytes32[]"},{name:"paymasterInput",type:"bytes"}]};class y extends L{constructor(e,t){super(),this.signer=e,R.defineReadOnly(this,"provider",e.provider),this.httpRpcClient=t}async getAddress(){return await this.signer.getAddress()}async signMessage(e){return await this.signer.signMessage(e)}async signTransaction(e){return await this.signer.signTransaction(e)}connect(e){return new y(this.signer.connect(e),this.httpRpcClient)}_signTypedData(e,t,r){return this.signer._signTypedData(e,t,r)}async sendTransaction(e){return await this.sendZkSyncTransaction(e)}async sendZkSyncTransaction(e){var l,P,w,f,x,I,S,v;let t=await this.populateTransaction(e);if(!t.chainId)throw new Error("ChainId is required to send a ZkSync transaction");if(!this.provider)throw new Error("Provider is required to send a ZkSync transaction");const r=await this.getAddress(),m=o.from(t.gasLimit||await this.provider.estimateGas(t)).mul(3),s=o.from(t.gasPrice||await this.provider.getGasPrice()).mul(2);t.maxFeePerGas?t.maxFeePerGas=t.maxFeePerGas.mul(2):t.maxFeePerGas=s,t.maxPriorityFeePerGas?t.maxPriorityFeePerGas=t.maxPriorityFeePerGas.mul(2):t.maxPriorityFeePerGas=s,t={...t,from:r,gasLimit:m,gasPrice:s,chainId:(await this.provider.getNetwork()).chainId,nonce:await this.provider.getTransactionCount(r),type:113,value:BigInt(0)};const n=await((l=this.httpRpcClient)==null?void 0:l.zkPaymasterData(t));t.customData={gasPerPubdata:u,factoryDeps:[],paymasterParams:{paymaster:n.paymaster,paymasterInput:n.paymasterInput}};const c={txType:g,from:BigInt(t.from||await this.getAddress()).toString(),to:BigInt(t.to||"0x0").toString(),gasLimit:t.gasLimit?Number(t.gasLimit):0,gasPerPubdataByteLimit:u,maxFeePerGas:o.from(t.maxFeePerGas).toNumber(),maxPriorityFeePerGas:o.from(t.maxPriorityFeePerGas).toNumber(),paymaster:BigInt(n.paymaster).toString(),nonce:o.from(t.nonce).toNumber(),value:o.from(t.value).toNumber(),data:t.data||"0x",factoryDeps:[],paymasterInput:G(n.paymasterInput)},a=await this._signTypedData({name:"zkSync",version:"2",chainId:t.chainId},W,c),i=this.serialize(t,a),d={from:((P=t.from)==null?void 0:P.toString())||await this.getAddress(),to:((w=t.to)==null?void 0:w.toString())||"",gas:((f=t.gasLimit)==null?void 0:f.toString())||"",maxFeePerGas:((x=t.maxFeePerGas)==null?void 0:x.toString())||"0",maxPriorityFeePerGas:((I=t.maxPriorityFeePerGas)==null?void 0:I.toString())||"0",signedTransaction:i,paymaster:n.paymaster},E=(await((S=this.httpRpcClient)==null?void 0:S.zkBroadcastTransaction(d))).transactionHash;return await((v=this.provider)==null?void 0:v.getTransaction(E))}serialize(e,t){if(!e.customData&&e.type!==g)return k(e,t);if(!e.chainId)throw Error("Transaction chainId isn't set!");function r(i,d){const h=p(o.from(i).toHexString());if(h.length>32)throw new Error(`Invalid length for ${d}!`);return h}if(!e.from)throw new Error("Explicitly providing `from` field is required for EIP712 transactions!");const m=e.from,s=e.customData??{},n=e.maxFeePerGas||e.gasPrice||0,c=e.maxPriorityFeePerGas||n,a=[r(e.nonce||0,"nonce"),r(c,"maxPriorityFeePerGas"),r(n,"maxFeePerGas"),r(e.gasLimit||0,"gasLimit"),e.to?T(e.to):"0x",r(e.value||0,"value"),e.data||"0x"];if(t){const i=_(t);a.push(r(i.recoveryParam,"recoveryParam")),a.push(p(i.r)),a.push(p(i.s))}else a.push(r(e.chainId,"chainId")),a.push("0x"),a.push("0x");if(a.push(r(e.chainId,"chainId")),a.push(T(m)),a.push(r(s.gasPerPubdata||u,"gasPerPubdata")),a.push((s.factoryDeps??[]).map(i=>b(i))),s.customSignature&&G(s.customSignature).length===0)throw new Error("Empty signatures are not supported!");return a.push(s.customSignature||"0x"),s.paymasterParams?a.push([s.paymasterParams.paymaster,b(s.paymasterParams.paymasterInput)]):a.push([]),z([[g],B(a)])}}class U extends F{constructor(e){super(),C(this,"chainId",1),this.config=e}async connect(e){if(this.personalWallet=e.personalWallet,this.chainId=await(await this.personalWallet.getSigner()).getChainId(),!await A(this.chainId))throw new Error("Invalid zksync chain id");const t=this.config.bundlerUrl||`https://${this.chainId}.bundler.thirdweb.com`,r=this.config.entryPointAddress||D;return this.httpRpcClient=new N(t,r,this.chainId,this.config.clientId,this.config.secretKey),this.getAddress()}disconnect(){throw new Error("Method not implemented.")}async getAddress(){return(await this.getSigner()).getAddress()}async getSigner(){if(!this.personalWallet)throw new Error("Wallet not connected");return new y(await this.personalWallet.getSigner(),this.httpRpcClient)}switchChain(e){throw new Error("Method not implemented.")}isConnected(){return Promise.resolve(!!this.personalWallet)}setupListeners(){throw new Error("Method not implemented.")}updateChains(e){throw new Error("Method not implemented.")}async getProvider(){if(!this.getSigner())throw new Error("Personal wallet not connected");const e=await this.getSigner();if(!e.provider)throw new Error("Provider not found");return e.provider}}export{U as ZkSyncConnector};

var j=Object.defineProperty;var H=(u,t,r)=>t in u?j(u,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[t]=r;var p=(u,t,r)=>(H(u,typeof t!="symbol"?t+"":t,r),r);import{J as K,e as T,f as F,G as _,B as n,r as g,k as m,s as C,T as l,v as x,o as W,z as y,F as B,H as I,K as Z,i as q,t as J,u as Y,y as N,O as Q,p as G,q as D,a as X,Y as S,a2 as v,$ as f,am as M,a1 as E,a0 as z,b4 as R}from"./index-42fc860b.js";import{c as O}from"./cleanCurrencyAddress-ded19cfe.browser.esm-855a9db3.js";import{g as L,h as P,a as tt}from"./marketplace-e3129e2f.browser.esm-0bf49cce.js";import{f as $,I as rt,a as et}from"./QueryParams-32a56510.browser.esm-8f630096.js";import{C as V}from"./contract-interceptor-d7b164a7.browser.esm-7eabd2ea.js";const U=(()=>S.object({assetContractAddress:v,tokenId:f,quantity:f.default(1),currencyContractAddress:v.default(M),pricePerToken:E,startTimestamp:z.default(new Date),endTimestamp:R,isReservedListing:S.boolean().default(!1)}))();let h=function(u){return u[u.UNSET=0]="UNSET",u[u.Created=1]="Created",u[u.Completed=2]="Completed",u[u.Cancelled=3]="Cancelled",u[u.Active=4]="Active",u[u.Expired=5]="Expired",u}({});class ut{constructor(t,r){p(this,"featureName",K.name);p(this,"createListing",m(async t=>{const r=await U.parseAsync(t);await P(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const a=await C(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),s=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(s)&&(r.startTimestamp=n.from(s));const o=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:O(r.currencyContractAddress),pricePerToken:a,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:c=>({id:this.contractWrapper.parseLogs("NewListing",c==null?void 0:c.logs)[0].args.listingId,receipt:c})});return o.setGasLimitMultiple(1.2),o}));p(this,"createListingsBatch",m(async t=>{const r=(await Promise.all(t.map(e=>this.createListing.prepare(e)))).map(e=>e.encode()),a=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:e=>this.contractWrapper.parseLogs("NewListing",e==null?void 0:e.logs).map(o=>({id:o.args.listingId,receipt:e}))});return a.setGasLimitMultiple(1.2),a}));p(this,"updateListing",m(async(t,r)=>{const a=await U.parseAsync(r);await P(this.contractWrapper,this.getAddress(),a.assetContractAddress,a.tokenId,await this.contractWrapper.getSignerAddress());const e=await C(this.contractWrapper.getProvider(),a.pricePerToken,a.currencyContractAddress),s=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:a.assetContractAddress,tokenId:a.tokenId,quantity:a.quantity,currency:O(a.currencyContractAddress),pricePerToken:e,startTimestamp:a.startTimestamp,endTimestamp:a.endTimestamp,reserved:a.isReservedListing}],parse:o=>({id:this.contractWrapper.parseLogs("UpdatedListing",o==null?void 0:o.logs)[0].args.listingId,receipt:o})});return s.setGasLimitMultiple(1.2),s}));p(this,"cancelListing",m(async t=>{const r=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]});return r.setGasLimitMultiple(1.2),r}));p(this,"buyFromListing",m(async(t,r,a)=>{a&&(a=await g(a));const e=await this.validateListing(n.from(t)),{valid:s,error:o}=await this.isStillValidListing(e,r);if(!s)throw new Error(`Listing ${t} is no longer valid. ${o}`);const c=a||await this.contractWrapper.getSignerAddress(),i=n.from(r),d=n.from(e.pricePerToken).mul(i),A=await this.contractWrapper.getCallOverrides()||{};await x(this.contractWrapper,d,e.currencyContractAddress,A);const w=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,c,i,e.currencyContractAddress,d],overrides:A});return w.setGasLimitMultiple(1.2),w}));p(this,"approveBuyerForReservedListing",m(async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))throw new Error(`Buyer ${r} already approved for listing ${t}.`);{const e=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!0]});return e.setGasLimitMultiple(1.2),e}}));p(this,"revokeBuyerApprovalForReservedListing",m(async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r)){const e=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!1]});return e.setGasLimitMultiple(1.2),e}else throw new Error(`Buyer ${r} not approved for listing ${t}.`)}));p(this,"approveCurrencyForListing",m(async(t,r,a)=>{const e=await this.validateListing(n.from(t)),s=await g(r);s===e.currencyContractAddress&&W(a===e.pricePerToken,"Approving listing currency with a different price.");const o=await this.contractWrapper.read("currencyPriceForListing",[t,s]);W(a===o,"Currency already approved with this price.");const c=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,s,a]});return c.setGasLimitMultiple(1.2),c}));p(this,"revokeCurrencyApprovalForListing",m(async(t,r)=>{const a=await this.validateListing(n.from(t)),e=await g(r);if(e===a.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const s=await this.contractWrapper.read("currencyPriceForListing",[t,e]);W(!s.isZero(),"Currency not approved.");const o=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,e,n.from(0)]});return o.setGasLimitMultiple(1.2),o}));this.contractWrapper=t,this.storage=r,this.events=new T(this.contractWrapper),this.encoder=new F(this.contractWrapper),this.interceptor=new V(this.contractWrapper),this.estimator=new _(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){const r=await this.getTotalCount(),a=n.from((t==null?void 0:t.start)||0).toNumber(),e=r.toNumber();if(e===0)throw new Error("No listings exist on the contract.");let s=[];s=(await L(a,e,(i,d)=>this.contractWrapper.read("getAllListings",[i,d]))).flat();const c=await this.applyFilter(s,t);return await Promise.all(c.map(i=>this.mapListing(i)))}async getAllValid(t){const r=await this.getTotalCount(),a=n.from((t==null?void 0:t.start)||0).toNumber(),e=r.toNumber();if(e===0)throw new Error("No listings exist on the contract.");let s=[];s=(await L(a,e,(i,d)=>this.contractWrapper.read("getAllValidListings",[i,d]))).flat();const c=await this.applyFilter(s,t);return await Promise.all(c.map(i=>this.mapListing(i)))}async getListing(t){const r=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){if(!(await this.validateListing(n.from(t))).isReservedListing)throw new Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await g(r)])}async isCurrencyApprovedForListing(t,r){return await this.validateListing(n.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await g(r)])}async currencyPriceForListing(t,r){const a=await this.validateListing(n.from(t)),e=await g(r);if(e===a.currencyContractAddress)return a.pricePerToken;if(!await this.isCurrencyApprovedForListing(t,e))throw new Error(`Currency ${e} is not approved for Listing ${t}.`);return await this.contractWrapper.read("currencyPriceForListing",[t,e])}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){let r=h.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=n.from(t.startTimestamp).gt(e)?h.Created:n.from(t.endTimestamp).lt(e)?h.Expired:h.Active;break;case 2:r=h.Completed;break;case 3:r=h.Cancelled;break}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await y(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:n.from(t.startTimestamp).toNumber(),asset:await $(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:n.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(t,r){if(!await tt(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const e=this.contractWrapper.getProvider(),s=(await B(()=>import("./IERC165-a27c30d6.js"),[])).default,o=new I(t.assetContractAddress,s,e),c=await o.supportsInterface(rt),i=await o.supportsInterface(et);if(c){const d=(await B(()=>import("./index-42fc860b.js").then(k=>k.f2),["assets/index-42fc860b.js","assets/index-2a3592d1.css"])).default,A=new I(t.assetContractAddress,d,e);let w;try{w=await A.ownerOf(t.tokenId)}catch{}const b=(w==null?void 0:w.toLowerCase())===t.creatorAddress.toLowerCase();return{valid:b,error:b?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}else if(i){const d=(await B(()=>import("./index-42fc860b.js").then(k=>k.f4),["assets/index-42fc860b.js","assets/index-2a3592d1.css"])).default,b=(await new I(t.assetContractAddress,d,e).balanceOf(t.creatorAddress,t.tokenId)).gte(r||t.quantity);return{valid:b,error:b?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}else return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}async applyFilter(t,r){let a=[...t];if(r){if(r.seller){const e=await g(r.seller);a=a.filter(s=>s.listingCreator.toString().toLowerCase()===(e==null?void 0:e.toString().toLowerCase()))}if(r.tokenContract){const e=await g(r.tokenContract);a=a.filter(s=>s.assetContract.toString().toLowerCase()===(e==null?void 0:e.toString().toLowerCase()))}r.tokenId!==void 0&&(a=a.filter(e=>{var s;return e.tokenId.toString()===((s=r==null?void 0:r.tokenId)==null?void 0:s.toString())}))}return r!=null&&r.count&&r.count<a.length?a.slice(0,r.count):a}}const at=(()=>S.object({assetContractAddress:v,tokenId:f,quantity:f.default(1),currencyContractAddress:v.default(M),minimumBidAmount:E,buyoutBidAmount:E,timeBufferInSeconds:f.default(900),bidBufferBps:f.default(500),startTimestamp:z.default(new Date),endTimestamp:R}))();class mt{constructor(t,r){p(this,"featureName",Z.name);p(this,"createAuction",m(async t=>{const r=at.parse(t);await P(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const a=await C(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),e=await C(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),o=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(o)&&(r.startTimestamp=n.from(o));const c=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:O(r.currencyContractAddress),minimumBidAmount:e,buyoutBidAmount:a,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],parse:i=>({id:this.contractWrapper.parseLogs("NewAuction",i.logs)[0].args.auctionId,receipt:i})});return c.setGasLimitMultiple(1.2),c}));p(this,"createAuctionsBatch",m(async t=>{const r=(await Promise.all(t.map(e=>this.createAuction.prepare(e)))).map(e=>e.encode()),a=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:e=>this.contractWrapper.parseLogs("NewAuction",e==null?void 0:e.logs).map(o=>({id:o.args.auctionId,receipt:e}))});return a.setGasLimitMultiple(1.2),a}));p(this,"buyoutAuction",m(async t=>{const r=await this.validateAuction(n.from(t)),a=await J(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,Y(r.buyoutBidAmount,a.decimals))}));p(this,"makeBid",m(async(t,r)=>{const a=await this.validateAuction(n.from(t)),e=await C(this.contractWrapper.getProvider(),r,a.currencyContractAddress);if(e.eq(n.from(0)))throw new Error("Cannot make a bid with 0 value");if(n.from(a.buyoutBidAmount).gt(0)&&e.gt(a.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const i=await this.isWinningBid(t,e);W(i,"Bid price is too low based on the current winning bid and the bid buffer")}else{const i=e,d=n.from(a.minimumBidAmount);W(i.gte(d),"Bid price is too low based on minimum bid amount")}const o=await this.contractWrapper.getCallOverrides()||{};await x(this.contractWrapper,e,a.currencyContractAddress,o);const c=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",overrides:o,args:[t,e]});return c.setGasLimitMultiple(1.2),c}));p(this,"cancelAuction",m(async t=>{if(await this.getWinningBid(t))throw new Error("Bids already made.");const a=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]});return a.setGasLimitMultiple(1.2),a}));p(this,"closeAuctionForBidder",m(async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const a=await this.validateAuction(n.from(t));try{const e=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[n.from(t)]});return e.setGasLimitMultiple(1.2),e}catch(e){throw e.message.includes("Marketplace: auction still active.")?new N(t.toString(),a.endTimeInSeconds.toString()):e}}));p(this,"closeAuctionForSeller",m(async t=>{const r=await this.validateAuction(n.from(t));try{const a=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[n.from(t)]});return a.setGasLimitMultiple(1.2),a}catch(a){throw a.message.includes("Marketplace: auction still active.")?new N(t.toString(),r.endTimeInSeconds.toString()):a}}));p(this,"executeSale",m(async t=>{const r=await this.validateAuction(n.from(t));try{const a=await this.getWinningBid(t);W(a,"No winning bid found");const e=this.encoder.encode("collectAuctionPayout",[t]),s=this.encoder.encode("collectAuctionTokens",[t]),o=l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[e,s]]});return o.setGasLimitMultiple(1.2),o}catch(a){throw a.message.includes("Marketplace: auction still active.")?new N(t.toString(),r.endTimeInSeconds.toString()):a}}));this.contractWrapper=t,this.storage=r,this.events=new T(this.contractWrapper),this.encoder=new F(this.contractWrapper),this.interceptor=new V(this.contractWrapper),this.estimator=new _(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){const r=await this.getTotalCount(),a=n.from((t==null?void 0:t.start)||0).toNumber(),e=r.toNumber();if(e===0)throw new Error("No auctions exist on the contract.");let s=[];s=(await L(a,e,(i,d)=>this.contractWrapper.read("getAllAuctions",[i,d]))).flat();const c=await this.applyFilter(s,t);return await Promise.all(c.map(i=>this.mapAuction(i)))}async getAllValid(t){const r=await this.getTotalCount(),a=n.from((t==null?void 0:t.start)||0).toNumber(),e=r.toNumber();if(e===0)throw new Error("No auctions exist on the contract.");let s=[];s=(await L(a,e,(i,d)=>this.contractWrapper.read("getAllValidAuctions",[i,d]))).flat();const c=await this.applyFilter(s,t);return await Promise.all(c.map(i=>this.mapAuction(i)))}async getAuction(t){const r=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(n.from(t));const r=await this.contractWrapper.read("getWinningBid",[t]);if(r._bidder!==q)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.read("isNewWinningBid",[t,r])}async getWinner(t){const r=await this.validateAuction(n.from(t)),a=await this.contractWrapper.read("getWinningBid",[t]),e=n.from(Math.floor(Date.now()/1e3)),s=n.from(r.endTimeInSeconds);if(e.gt(s)&&a._bidder!==q)return a._bidder;const i=(await new T(this.contractWrapper).getEvents("AuctionClosed")).find(d=>d.data.auctionId.eq(n.from(t)));if(!i)throw new Error(`Could not find auction with ID ${t} in closed auctions`);return i.data.winningBidder}async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[r,a,e]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(n.from(t))]),s=a?n.from(a.bidAmount):n.from(e.minimumBidAmount),o=s.add(s.mul(r).div(1e4));return y(this.contractWrapper.getProvider(),e.currencyContractAddress,o)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw console.error(`Error getting the auction with id ${t}`),r}}async mapAuction(t){let r=h.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=n.from(t.startTimestamp).gt(e)?h.Created:n.from(t.endTimestamp).lt(e)?h.Expired:h.Active;break;case 2:r=h.Completed;break;case 3:r=h.Cancelled;break}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await y(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await y(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:n.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:n.from(t.bidBufferBps).toNumber(),startTimeInSeconds:n.from(t.startTimestamp).toNumber(),endTimeInSeconds:n.from(t.endTimestamp).toNumber(),asset:await $(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,a,e){const s=await g(r),o=await g(a);return{auctionId:t,bidderAddress:s,currencyContractAddress:o,bidAmount:e,bidAmountCurrencyValue:await y(this.contractWrapper.getProvider(),o,e)}}async applyFilter(t,r){let a=[...t];if(r){if(r.seller){const e=await g(r.seller);a=a.filter(s=>s.auctionCreator.toString().toLowerCase()===(e==null?void 0:e.toString().toLowerCase()))}if(r.tokenContract){const e=await g(r.tokenContract);a=a.filter(s=>s.assetContract.toString().toLowerCase()===(e==null?void 0:e.toString().toLowerCase()))}r.tokenId!==void 0&&(a=a.filter(e=>{var s;return e.tokenId.toString()===((s=r==null?void 0:r.tokenId)==null?void 0:s.toString())}))}return r!=null&&r.count&&r.count<a.length?a.slice(0,r.count):a}}const st=(()=>S.object({assetContractAddress:v,tokenId:f,quantity:f.default(1),currencyContractAddress:v.default(M),totalPrice:E,endTimestamp:R}))();class lt{constructor(t,r){p(this,"featureName",Q.name);p(this,"makeOffer",m(async t=>{const r=await st.parseAsync(t),a=await this.contractWrapper.getChainID(),e=G(r.currencyContractAddress)?D[a].wrapped.address:r.currencyContractAddress,s=await C(this.contractWrapper.getProvider(),r.totalPrice,e),o=await this.contractWrapper.getCallOverrides();return await x(this.contractWrapper,s,e,o),l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:e,totalPrice:s,expirationTimestamp:r.endTimestamp}],parse:c=>({id:this.contractWrapper.parseLogs("NewOffer",c==null?void 0:c.logs)[0].args.offerId,receipt:c})})}));p(this,"cancelOffer",m(async t=>l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]})));p(this,"acceptOffer",m(async t=>{const r=await this.validateOffer(n.from(t)),{valid:a,error:e}=await this.isStillValidOffer(r);if(!a)throw new Error(`Offer ${t} is no longer valid. ${e}`);const s=await this.contractWrapper.getCallOverrides()||{};return await P(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),l.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:s})}));this.contractWrapper=t,this.storage=r,this.events=new T(this.contractWrapper),this.encoder=new F(this.contractWrapper),this.interceptor=new V(this.contractWrapper),this.estimator=new _(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){const r=await this.getTotalCount(),a=n.from((t==null?void 0:t.start)||0).toNumber(),e=r.toNumber();if(e===0)throw new Error("No offers exist on the contract.");let s=[];s=(await L(a,e,(i,d)=>this.contractWrapper.read("getAllOffers",[i,d]))).flat();const c=await this.applyFilter(s,t);return await Promise.all(c.map(i=>this.mapOffer(i)))}async getAllValid(t){const r=await this.getTotalCount(),a=n.from((t==null?void 0:t.start)||0).toNumber(),e=r.toNumber();if(e===0)throw new Error("No offers exist on the contract.");let s=[];s=(await L(a,e,(i,d)=>this.contractWrapper.read("getAllValidOffers",[i,d]))).flat();const c=await this.applyFilter(s,t);return await Promise.all(c.map(i=>this.mapOffer(i)))}async getOffer(t){const r=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(r)}async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw console.error(`Error getting the offer with id ${t}`),r}}async mapOffer(t){let r=h.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=n.from(t.expirationTimestamp).lt(e)?h.Expired:h.Active;break;case 2:r=h.Completed;break;case 3:r=h.Cancelled;break}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await y(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await $(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:n.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(t){if(n.from(Math.floor(Date.now()/1e3)).gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};const a=await this.contractWrapper.getChainID(),e=G(t.currencyContractAddress)?D[a].wrapped.address:t.currencyContractAddress,s=this.contractWrapper.getProvider(),o=(await B(()=>import("./index-42fc860b.js").then(A=>A.f1),["assets/index-42fc860b.js","assets/index-2a3592d1.css"])).default,c=new X(s,e,o,{},this.storage);return(await c.read("balanceOf",[t.offerorAddress])).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${e}`}:(await c.read("allowance",[t.offerorAddress,this.getAddress()])).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${e}`}:{valid:!0,error:""}}async applyFilter(t,r){let a=[...t];if(r){if(r.offeror){const e=await g(r.offeror);a=a.filter(s=>s.offeror.toString().toLowerCase()===(e==null?void 0:e.toString().toLowerCase()))}if(r.tokenContract){const e=await g(r.tokenContract);a=a.filter(s=>s.assetContract.toString().toLowerCase()===(e==null?void 0:e.toString().toLowerCase()))}r.tokenId!==void 0&&(a=a.filter(e=>{var s;return e.tokenId.toString()===((s=r==null?void 0:r.tokenId)==null?void 0:s.toString())}))}return r!=null&&r.count&&r.count<a.length?a.slice(0,r.count):a}}export{ut as M,mt as a,lt as b};
